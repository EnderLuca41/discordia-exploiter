using Discordia.Lib.Types;
using Discordia.Lib.Exceptions;
using DSharpPlus;
using DSharpPlus.Entities;
using DSharpPlus.Exceptions;

namespace Discordia.Lib.Discord;

public static class UserInteraction
{
    /// <exception cref="ArgumentException">If index is negative</exception>
    /// <exception cref="UserNotFoundException">Gets thrown when the user does not exist</exception>
    /// <exception cref="IndexOutOfRangeException">If <paramref name="serverIndex"/> is not present in the server list</exception>
    /// <exception cref="UnauthorizedAccessException">If GUILD_MEMBERS Intent is not activated</exception>
    /// <exception cref="ServerErrorException">Thrown when discord is unable to process the request</exception>
    public static async Task<IEnumerable<DiscordMember>> GetMembersList(DiscordClient client, int serverIndex)
    {
        if(serverIndex < 0)
            throw new ArgumentException("Index must be positive");

        if(client.Guilds.Count <= serverIndex)
            throw new IndexOutOfRangeException("Index is not present in the server list");
        
        if(!client.Intents.HasFlag(DiscordIntents.GuildMembers))
            throw new UnauthorizedAccessException("GUILD_MEMBERS intent is not activated");
        
        var server = client.Guilds.Values.ElementAt(serverIndex);
        return await server.GetAllMembersAsync();
    }

    
    /// <exception cref="UserNotFoundException">Gets thrown when the user does not exist</exception>
    public static BasicUserInfo GetBasicUserInfo(IEnumerable<DiscordMember> discordMembers, DiscordUsername username)
    {

        var user = discordMembers
            .SingleOrDefault(user => user.Username == username.Name && user.Discriminator == username.Discriminator);
        
        if(user == default)
            throw new UserNotFoundException("The Specified user does not exist");

        return new BasicUserInfo(user.Id, user.Username, user.Discriminator,
            user.Email, user.Flags, user.IsBot,
            user.IsSystem, user.Locale, user.MfaEnabled,
            user.OAuthFlags, user.PremiumType, user.Verified);
    }
}